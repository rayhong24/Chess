use std::fmt::DebugSet;

use crate::enums::{Colour, File};
use crate::coords::Coords;
use crate::moves::move_ray::MoveRay;
use crate::pieces::Piece;

#[derive(Debug, Clone)]
pub struct King {
    pub colour: Colour,
    pub position: Coords,
}

impl Piece for King {
    fn colour(&self) -> Colour {
        self.colour
    }
    fn get_representation(&self) -> char {
        match self.colour {
            Colour::White => 'K',
            Colour::Black => 'k',
        }
    }
    fn get_move_rays(&self, from: Coords) -> Vec<MoveRay> {
        let mut destinations = Vec::new();
        for (rank_diff, file_diff) in &[
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),          (0, 1),
            (1, -1),  (1, 0),  (1, 1),
        ] {
            if let Some(new_coords) = from.get_neighbour(*rank_diff, *file_diff) {
                let move_ray = MoveRay::new(*rank_diff, *file_diff, 1, true, false);
                destinations.push(move_ray);
            }
        }

        return destinations;
    }
}


#[test]
fn test_king_colour_and_representation() {
    let king_w = King { colour: Colour::White, position: Coords::new(1, File::E) };
    let king_b = King { colour: Colour::Black, position: Coords::new(8, File::E) };
    assert_eq!(king_w.colour(), Colour::White);
    assert_eq!(king_b.colour(), Colour::Black);
    assert_eq!(king_w.get_representation(), 'K');
    assert_eq!(king_b.get_representation(), 'k');
}

#[test]
fn test_king_moves_center() {
    let king = King { colour: Colour::White, position: Coords::new(4, File::E) };
    let from = Coords::new(4, File::E);
    let move_rays = king.get_move_rays(from.clone());

    // Collect all destination coords generated by the king's move rays
    let mut moves: Vec<Coords> = move_rays
        .iter()
        .filter_map(|ray| ray.generate_coords(&from).next())
        .collect();

    let expected = vec![
        Coords::new(3, File::D), Coords::new(3, File::E), Coords::new(3, File::F),
        Coords::new(4, File::D),                       Coords::new(4, File::F),
        Coords::new(5, File::D), Coords::new(5, File::E), Coords::new(5, File::F),
    ];
    for mv in expected {
        assert!(moves.contains(&mv), "King should be able to move to {:?}", mv);
    }
    assert_eq!(moves.len(), 8);
}

#[test]
fn test_king_moves_corner() {
    let king = King { colour: Colour::White, position: Coords::new(1, File::A) };
    let from = Coords::new(1, File::A);
    let move_rays = king.get_move_rays(from.clone());

    let mut moves: Vec<Coords> = move_rays
        .iter()
        .filter_map(|ray| ray.generate_coords(&from).next())
        .collect();

    let expected = vec![
        Coords::new(1, File::B),
        Coords::new(2, File::A),
        Coords::new(2, File::B),
    ];
    for mv in expected {
        assert!(moves.contains(&mv), "King should be able to move to {:?}", mv);
    }
    assert_eq!(moves.len(), 3);
}